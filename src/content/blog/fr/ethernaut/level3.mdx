---
author: Amine El
pubDatetime: 2023-04-20T15:22:00Z
title: R√©soudre le niveau 3 d'Ethernaut "Coin Flip"
language: fr
postSlug: "blockchain-randomness-challenge"
featured: true
draft: false
tags:
  - ethernaut
  - al√©atoire
  - hazard
  - chainlink
  - solidity
ogImage: ""
description: Explorez les d√©fis de g√©n√©ration de nombres al√©atoires dans la blockchain. Plongez dans le d√©fi Ethernaut Coin Flip et d√©couvrez les risques li√©s √† la g√©n√©ration non s√©curis√©e de nombres al√©atoires dans les contrats intelligents. Enfin, s√©curisez votre contrat intelligent Coin Flip avec la solution fiable et robuste de Chainlink VRF v2.
---

import CodeLink from "@components/CodeLink.astro";
import ImageWithZoom from "@components/ImageWithZoom.tsx";

Dans ce guide, vous apprendrez √† g√©n√©rer des nombres al√©atoires dans la blockchain:

- Tout d'abord, nous pr√©senterons l'al√©atoire et pourquoi il est difficile d'en g√©n√©rer dans la blockchain (voir [Blockchain et al√©atoire](#blockchain-et-al√©atoire)).
- Ensuite, vous r√©soudrez le [d√©fi Ethernaut Coin Flip](https://ethernaut.openzeppelin.com/level/3) pour montrer comment pirater un contrat intelligent qui utilise des nombres al√©atoires non s√©curis√©s (voir [Probl√®me](#probl√®me-avec-lal√©atoire-non-s√©curis√©--le-d√©fi-coin-flip) ).
- Enfin, vous corrigerez le contrat intelligent Ethernault Coin Flip en utilisant une source d'al√©atoire s√©curis√©e : Chainlink VRF v2 (voir [Solution](#solution--correction-de-coinflip---chainlink-vrf-v2) ).

## Toc

## Blockchain et al√©atoire

[L'al√©atoire](https://www.larousse.fr/dictionnaires/francais/al%C3%A9atoire/2155) fait r√©f√©rence √† l'absence de pr√©visibilit√©. Par exemple, le r√©sultat d'un lancer de d√©s est impr√©visible.

Les blockchains sont des syst√®mes d√©terministes o√π les m√™mes entr√©es produisent toujours les m√™mes sorties. Cet attribut _d√©terministe_ permet aux n≈ìuds validateurs de la blockchain (dans le m√©canisme de consensus [preuve d'enjeu](https://ethereum.org/fr/developers/docs/consensus-mechanisms/pos/)) ou aux n≈ìuds de minage de la blockchain (dans le m√©canisme de consensus [preuve de travail](https://ethereum.org/fr/developers/docs/consensus-mechanisms/pow/)) d'atteindre un consensus. Ils doivent tous parvenir au m√™me r√©sultat lors de l'ex√©cution d'une transaction. Ainsi, les syst√®mes de blockchain ne fournissent aucune solution native pour g√©n√©rer de l'al√©atoire, car fournir une solution pour g√©n√©rer de l'al√©atoire contredirait leur attribut _d√©terministe_.

Cela signifie-t-il que l'al√©atoire n'est pas utilis√© dans la blockchain ? Pas si vite‚Ä¶
L'al√©atoire est d√©j√† utilis√© (liste non exhaustive) dans les cas suivants :

- Preuve d'enjeu : s√©lection al√©atoire des responsabilit√©s des validateurs.
- NFT : attribuer des attributs al√©atoires lors de la g√©n√©ration de NFT.
- Jeux : matchmaking, coups critiques (combats)... Etc.

Lisez ce [blog](https://chain.link/education-hub/rng-in-blockchain-use-cases) pour une liste plus compl√®te.

Maintenant, on pourrait se poser les questions suivantes :

- √âtant donn√© que les blockchains sont d√©terministes, comment ces applications blockchain obtiennent-elles de l'al√©atoire ?
- Et, plus important encore, comment garantir que l'al√©atoire est √©quitable et que personne ne peut biaiser le syst√®me ? Imaginez un jeu avec gains utilisant une source d'al√©atoire biais√©e‚Ä¶

Pour r√©pondre √† ces questions, vous pourriez utiliser (mais s'il vous pla√Æt, ne le faites pas üôÇ) des solutions na√Øves et, surtout, **non s√©curis√©es** :

- Op√©rateur [Oracle](https://ethereum.org/fr/developers/docs/oracles/) opaque : Demander de l'al√©atoire √† un op√©rateur Oracle qui ne fournit pas de preuves/garanties cryptographiques de g√©n√©ration √©quitable. Un oracle malveillant ou compromis pourrait fournir des donn√©es biais√©es √† vos contrats intelligents et nuire √† vos utilisateurs. Par exemple, vous avez cr√©√© une loterie sur et demand√© de l'al√©atoire √† un oracle _opaque_ pour d√©terminer les num√©ros gagnants. L'oracle pourrait participer √† la loterie et g√©n√©rer des nombres "al√©atoires" qui arrangeraient son jeu.
- Solution de contournement: S'appuyer sur les [horodatages ou les hachages](https://docs.soliditylang.org/en/v0.8.17/units-and-global-variables.html#block-and-transaction-properties) des blocs. Cependant, les mineurs ayant un enjeu dans le jeu pourraient d√©cider quand "miner" une transaction. Ainsi, influen√ßant les valeurs d'horodatage et de hachage.

La **solution** consiste √† utiliser un g√©n√©rateur de nombres al√©atoires (RNG) √©quitable et prouvable, tel que [Chainlink VRF](https://chain.link/vrf), dans lequel chaque r√©sultat al√©atoire est impartial et v√©rifi√© cryptographiquement sur la cha√Æne. Pour en savoir plus sur les fonctions al√©atoires v√©rifiables, vous pouvez lire cet [article](https://chain.link/education-hub/verifiable-random-function-vrf).

## Probl√®me avec l'al√©atoire non s√©curis√© : le d√©fi Coin Flip

Pour illustrer les risques importants de s'appuyer sur des solutions de contournement, nous allons pirater le [d√©fi Coin Flip Ethernaut](https://ethernaut.openzeppelin.com/level/3).

### Objectif

Dans ce d√©fi, vous devez deviner le r√©sultat d'un lancer de pi√®ce. Devinez le r√©sultat dix fois de suite, et vous remportez le d√©fi.

<CodeLink
  httplink="https://raw.githubusercontent.com/web3station/CoinFlip/main/contracts/CoinFlip.sol"
  lang="solidity"
/>

### Analyse du contrat

Pour deviner le r√©sultat d'un lancer de pi√®ce, il faut appeler la fonction `flip` et fournir un bool√©en (vrai/faux) en entr√©e. Passons en revue la fonction `flip` :

- La premi√®re ligne calcule une valeur "al√©atoire" bas√©e sur le hachage (`blockhash`) du bloc pr√©c√©dent (`block.number‚Ää-‚Ää1`). Comme `blockhash` renvoie une valeur _bytes32_, le r√©sultat est [converti](https://docs.soliditylang.org/en/v0.8.17/types.html#explicit-conversions) de _bytes32_ en _uint256_ pour obtenir un entier non sign√© de 256 bits.

  ```solidity
  uint256 blockValue = uint256(blockhash(block.number - 1))
  ```

- Ensuite, la fonction v√©rifie qu'elle est appel√©e une seule fois dans un bloc donn√© : si elle a d√©j√† √©t√© appel√©e dans le m√™me bloc, la fonction renvoie une erreur.

  ```solidity
  if (lastHash == blockValue) {
   revert();
  }
  lastHash = blockValue;
  ```

- `coinFlip` est calcul√© en divisant blockValue par `FACTOR`. `FACTOR` est une variable d'√©tat uint256 [variable d'√©tat](https://docs.soliditylang.org/en/v0.8.17/structure-of-a-contract.html#state-variables). Si la valeur de `coinFlip` est `1`, alors `side` sera `true`; sinon, il sera `false`. N'oubliez pas qu'en Solidity, la [division d'entiers](https://docs.soliditylang.org/en/v0.8.17/types.html#division) donne un entier.

  ```solidity
  uint256 coinFlip = blockValue / FACTOR;
  bool side = coinFlip == 1 ? true : false;
  ```

- Le contrat a un compteur (`consecutiveWins`). `side` est compar√© √† la valeur devin√©e `_guess`. Si la valeur devin√©e est correcte, alors le compteur est incr√©ment√©. Sinon, le compteur est remis √† z√©ro.

  ```solidity
  if (side == _guess) {
    consecutiveWins++;
    return true;
  } else {
    consecutiveWins = 0;
    return false;
  }
  ```

### Piratage du contrat

D√©montrons qu'utiliser le `blockhash` pour g√©n√©rer de l'al√©atoire est une mauvaise id√©e et que nous pouvons deviner le r√©sultat du lancer de pi√®ce.

La solution la plus simple consiste √† d√©ployer un contrat avec une fonction qui calcule le lancer de pi√®ce attendu en utilisant le m√™me algorithme que la fonction `flip`, puis appelle le contrat `CoinFlip` avec le r√©sultat attendu. Plusieurs solutions document√©es en ligne existent:

- [solution1](https://www.goodbytes.be/article/ethernaut-walkthrough-level-3-coin-flip).
- [solution2](https://hackernoon.com/how-to-solve-the-level-3-of-the-ethernaut-game).

En guise de d√©fi, j'ai voulu pirater le contrat hors cha√Æne sans d√©ployer un autre contrat. La solution fonctionne bien dans un environnement local. Cependant, il n'est pas toujours facile √† utiliser sur un testnet public (par exemple, Sepolia), car on n'est pas s√ªr √† 100% que les mineurs incluent les transactions dans le bloc attendu. **Note** : si vous pouvez affiner le code pour le rendre toujours fonctionnel sur Sepolia, veuillez ouvrir une PR üòâ. Le r√©po peut √™tre trouv√© [ici](https://github.com/web3station/CoinFlip).

#### Sur Blockchain locale

Afin de tester:

- Veuillez ouvrir un terminal, cloner le r√©po, et installer toutes les d√©pendances :

  ```bash
  git clone git@github.com:web3station/CoinFlip.git && cd CoinFlip
  yarn
  ```

- Compilez les contrats:

  ```bash
  yarn compile
  ```

- Dans un nouveau terminal, d√©marrez un environnement local :

  ```bash
  yarn start-node
  ```

- Deployez CoinFlip:

  ```bash
  yarn deploy-coinflip
  ```

- Notez l'addresse du contrat d√©ploy√©:

  <ImageWithZoom
    client:only
    src="/blogs/ethernaut/level3/contract-deployed.png"
    alt="Contrat CoinFlip d√©ploy√©"
  />

- Piratez le contrat:

  ```bash
  yarn flip <your-address>
  ```

  <ImageWithZoom
    client:only
    src="/blogs/ethernaut/level3/hack-the-contract.png"
    alt="Piratez le contrat CoinFlip sur votre blockchain locale"
  />

Si vous √™tes int√©ress√© par le script, vous pouvez le trouver [ici](https://github.com/web3station/CoinFlip/blob/main/tasks/flip.ts).

#### Sur un testnet public

- Veuillez ouvrir un terminal, cloner le r√©po, et installer toutes les d√©pendances :

  ```bash
  git clone git@github.com:web3station/CoinFlip.git && cd CoinFlip
  yarn
  ```

- Compilez les contrats:

  ```bash
  yarn compile
  ```

- Copiez `.env.example` vers `.env` afin de g√©n√©rer un nouveau fichier de variables d'environnement:

  ```bash
  cp .env.example .env
  ```

- Ouvrez `.env` and completez les variables obligatoires.

- Deployez CoinFlip. Example on Sepolia:

  ```bash
  yarn deploy-coinflip --network sepolia
  ```

      <ImageWithZoom
        client:only
        src="/blogs/ethernaut/level3/contract-deployed-sepolia.png"
        alt="CoinFlip d√©ploy√© sur Sepolia testnet"
      />

- Notez l'addresse du contrat d√©ploy√©.

- Piratez le contrat. **Note** : Le principal d√©fi consiste √† s'assurer que les validateurs/mineurs incluent la transaction dans le bon bloc. En fonction de la congestion du r√©seau, vous pourriez peut-√™tre remarquer que les victoires cons√©cutives red√©marrent, ce qui signifie que les validateurs n'ont pas inclus la transaction dans le bloc attendu.

  ```bash
  yarn flip <your-address> --network sepolia
  ```

  <ImageWithZoom
    client:only
    src="/blogs/ethernaut/level3/hack-the-contract-sepolia.png"
    alt="Piratez le contrat sur Sepolia testnet"
  />

## Solution : Correction de CoinFlip - Chainlink VRF v2

Maintenant que nous avons vu comment nous pourrions deviner avec pr√©cision le r√©sultat de la fonction `coinFlip`, utilisons [Chainlink VRF](https://chain.link/vrf) pour obtenir une s√©curit√© al√©atoire et corriger le contrat `CoinFlip`.

### Introduction √† Chainlink VRF v2

Chainlink Verifiable Random Function (VRF) est une solution RNG standard, permettant aux contrats intelligents et aux syst√®mes hors cha√Æne d'acc√©der √† une source de hasard v√©rifiable en utilisant un calcul hors cha√Æne. Vous pouvez en apprendre davantage sur Chainlink VRF [ici](https://chain.link/vrf).

Au moment de la r√©daction, il existait deux versions: v1 et v2. Nous allons utiliser v2 car il inclut plusieurs am√©liorations. Notez que Chainlink VRF v2 offre deux m√©thodes pour demander des nombres al√©atoires. Comme la [documentation](https://docs.chain.link/vrf/v2/introduction#two-methods-to-request-randomness) indique:

> [Abonnement](https://docs.chain.link/vrf/v2/subscription/): Cr√©ez un compte d'abonnement et approvisionnez son solde avec des jetons LINK. Les utilisateurs peuvent ensuite connecter plusieurs contrats consommateurs au compte d'abonnement. Lorsque les contrats consommateurs demandent des nombres al√©atoires, les frais de transaction sont calcul√©s √† la fin de celle-ci, et le solde d'abonnement est d√©duit en cons√©quence. Cette m√©thode vous permet de financer les demandes de plusieurs contrats consommateurs √† partir d'un seul abonnement.

> [Financement direct](https://docs.chain.link/vrf/v2/direct-funding/): Les contrats consommateurs paient directement avec LINK lorsqu'ils demandent des valeurs al√©atoires. Vous devez financer directement vos contrats consommateurs et vous assurer qu'il y a suffisamment de jetons LINK pour payer les requ√™tes.

Comme nous allons d√©ployer un contrat consommateur et l'utiliser pour une demande unique, la m√©thode [Financement direct](https://docs.chain.link/vrf/v2/direct-funding/) semble plus appropri√©e √† notre cas d'utilisation.

### Pr√©requis

Pour ex√©cuter le prochain tutoriel, vous aurez besoin de :

- [Portefeuille Metamask](https://metamask.io/).
- [Environnement de d√©veloppement Remix](https://remix.ethereum.org/). Si vous n'avez jamais d√©ploy√© de contrat en utilisant Remix IDE, suivez ce [tutoriel pour d√©butants](https://docs.chain.link/getting-started/deploy-your-first-contract).
- Le test sera effectu√© sur le r√©seau de test Sepolia. Par cons√©quent, vous aurez besoin de suffisamment d'ETH Sepolia pour d√©ployer et interagir avec votre contrat. Vous aurez √©galement besoin de suffisamment de jetons LINK Sepolia pour payer le r√©seau Chainlink afin d'obtenir des nombres al√©atoires. Vous pouvez obtenir des LINKs de test aupr√®s du [Chainlink faucet](https://faucets.chain.link/).

### Correction CoinFlip

Ci-dessous se trouve le contrat `CoinFlipFix`. Veuillez noter que certaines variables sont cod√©es en dur et d√©finies en tant que variables d'√©tat √† des fins √©ducatives, ce qui rend ce contrat inadapt√© au d√©ploiement en production.

<CodeLink
  httplink="https://raw.githubusercontent.com/web3station/CoinFlip/main/contracts/CoinFlipFix.sol"
  lang="solidity"
/>

La meilleure fa√ßon de comprendre la m√©thode Direct Funding de Chainlink VRF v2 est d'essayer le tutoriel _Get a Random Number_ de la [documentation officielle](https://docs.chain.link/vrf/v2/direct-funding/examples/get-a-random-number).

Un ou plusieurs nombres al√©atoires sont demand√©s √† un oracle, qui g√©n√®re un tableau de nombres al√©atoires et une preuve cryptographique. Ensuite, l'oracle renvoie les r√©sultats dans un rappel. Cette s√©quence est connue sous le nom de _Request and Receive cycle_. Pour cette raison, il existe deux fonctions :

- `flip` : utilis√©e pour demander un nombre al√©atoire. \*_Notez_: Vous pourriez nommer votre fonction comme vous le souhaitez, tant que la fonction appelle `requestRandomness`.

- `fulfillRandomWords` : c'est la fonction de rappel o√π vous pouvez traiter les mots al√©atoires re√ßus. La signature de la fonction ne peut pas √™tre modifi√©e. En fait, remarquez que votre contrat h√©rite de `VRFV2WrapperConsumerBase` et que le rappel est d√©fini [ici](https://github.com/smartcontractkit/chainlink/blob/b3abf270de833c6c0d29e28dc0de738dda03ab7d/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol#L79).

Analysons la nouvelle fonction `flip` :

- Elle re√ßoit un tableau bool√©en de `_guesses` en entr√©e, dont la longueur doit √™tre de 10 (nous demandons aux joueurs de deviner les dix flips de la pi√®ce √† l'avance. Ils gagnent s'ils ont tout juste).

- Ensuite, elle appelle Chainlink VRF (`requestRandomness`) pour demander dix mots al√©atoires. La fonction retourne un identifiant unique : `requestId`. Notez que requestRandomness prend soin de payer l'oracle en jetons LINK dans la m√™me transaction. Le montant est bas√© sur `callbackGasLimit`, qui est la limite de la quantit√© de gaz √† utiliser pour appeler la fonction de rappel `fulfillRandomWords` **plus** une prime. Le mod√®le des co√ªts est d√©taill√© dans la [documentation officielle](https://docs.chain.link/vrf/v2/estimating-costs).

- L'identifiant de la demande, le montant pay√© et les valeurs devin√©es par le joueur `_guesses` sont stock√©s dans la table de hachage `requests`.

  ```solidity
  requests[requestId] = RequestStatus({

  paid: VRF_V2_WRAPPER.calculateRequestPrice(callbackGasLimit),
  randomWords: new uint256[](0),
  fulfilled: false,
  sides: new bool[](0),
  guesses: _guesses
  });
  ```

D'autre part, la fonction de rappel `fulfillRandomWords` traite les mots al√©atoires re√ßus :

- Marque la demande comme √©tant remplie et stocke les mots al√©atoires re√ßus.

  ```solidity
  requests[_requestId].fulfilled = true;

  requests[_requestId].randomWords = _randomWords;
  ```

- Ensuite, la fonction calcule `side` pour chaque mot al√©atoire re√ßu en le divisant par `FACTOR` (logique similaire au d√©fi Ethernaut CoinFlip).

  ```solidity
  bool[] memory sides = new bool[](10);

  uint256 coinFlip;
  for (uint8 i = 0; i < _randomWords.length; i++) {
  coinFlip = _randomWords[i] / FACTOR;
  sides[i] = coinFlip == 1 ? true : false;
  }
  requests[_requestId].sides = sides;
  ```

- Ensuite, la fonction appelle une fonction priv√©e `getGameResults` qui compare les valeurs devin√©es par les joueurs avec les nombres al√©atoires. La fonction renvoie le nombre de r√©sultats corrects `correctResults` et un bool√©en `isWinner` d√©fini √† true si le joueur a tout devin√© correctement.

- Enfin, il √©met un √©v√©nement `GameResult` avec les r√©sultats du jeu.

Notez qu'√† tout moment, un joueur peut appeler `getRequestStatus` pour obtenir les r√©sultats d'un jeu sp√©cifique (identifi√© de mani√®re unique par `_requestId`).

### Test

Maintenant, testons le contrat `CoinFlipFix`:

- Ouvrez [Remix IDE](https://remix.ethereum.org/#lang=en&optimize=false&runs=200&evmVersion=null). Cr√©ez un nouveau fichier Solidity `CoinFlipFix.sol` et copiez/collez le code ci-dessus.

- Compilez le contrat, puis d√©ployez-le sur le testnet Sepolia.

- Alimentez votre contrat en tokens LINK (~3 tokens LINK par appel de `flip`). Vous pouvez suivre [ce tutoriel](https://docs.chain.link/resources/fund-your-contract/) pour apprendre √† financer un contrat.

- Maintenant, essayez d'obtenir dix r√©sultats de lancer de pi√®ce. Par exemple : `[false,false,true,true,true,true,false,true,true,false]`. Ensuite, cliquez sur `transact`.

  <ImageWithZoom
    client:only
    src="/blogs/ethernaut/level3/coinflix-fix-transact.png"
    alt="CoinFlipFix liste transactions"
  />

- Metamask s'ouvre et vous demande de confirmer la transaction. **Note importante**: Remix IDE ne d√©finit pas la bonne limite de gaz. Pour que cet exemple fonctionne, d√©finissez une limite de gaz de _400 000_, comme [expliqu√© ici](https://support.metamask.io/hc/en-us/articles/360022895972).

- Une fois confirm√©, cliquez sur `lastRequestId` pour obtenir l'ID de la requ√™te.

  <ImageWithZoom
    client:only
    src="/blogs/ethernaut/level3/coinflix-fix-lastRequestId.png"
    alt="CoinFlipFix dernier identifiant"
  />

- Attendez quelques minutes, puis cliquez sur `getRequestStatus` avec votre ID de requ√™te. Dans mon test, j'ai obtenu six r√©sultats corrects.

  <ImageWithZoom
    client:only
    src="/blogs/ethernaut/level3/coinflix-fix-getRequestStatus.png"
    alt="CoinFlipFix information requete"
  />

- Jouez plusieurs fois et voyez si vous pouvez gagner le jeu üôÇ.

## R√©flexions finales

Comme discut√© au d√©but, _l'al√©atoire_ est essentiel pour de nombreux projets : NFTs, jeux, loteries, etc. Lors du d√©veloppement d'un contrat intelligent, vous devez pr√™ter une grande attention √† l'exp√©rience utilisateur ainsi qu'√† leur s√©curit√© : s'appuyer sur des solutions hors cha√Æne non s√©curis√©es (par exemple, des oracles sans aucune v√©rification cryptographique) ou des solutions de contournement sur cha√Æne (par exemple, blockhashes) doit √™tre exclu, et vous devriez vous appuyer sur des oracles qui fournissent une randomisation qui peut √™tre v√©rifi√©e cryptographiquement sur cha√Æne. Pour en savoir plus sur Chainlink VRF :

- [Site officiel](https://chain.link/vrf).

- [Pourquoi la vraie Randomit√© est importante dans web3](https://chain.link/education-hub/randomness-web3).

- [Verifiable Random Function (VRF)](https://chain.link/education-hub/verifiable-random-function-vrf).
